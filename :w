import { Edit2Icon, EditIcon } from 'lucide-react';
import React, {
  Dispatch,
  SetStateAction,
  useEffect,
  useRef,
  useState,
} from 'react';
import { Button } from '../../ui/button';

type DrawMode = 'draw' | 'rect';
interface Point {
  x: number;
  y: number;
}

export default function PaintApp() {
  const [mode, setMode] = useState<DrawMode>('draw');
  return (
    <div className='flex flex-row h-full w-full'>
      <div className='w-[90px]'>
        <SideBar setMode={setMode} />
      </div>
      <div className='flex-1 h-full bg-[var(--terminal-white)]'>
        <Canvas mode={mode} />
      </div>
    </div>
  );
}

const sidebarData = [
  { name: 'Draw', icon: Edit2Icon },
  { name: 'Rect', icon: Edit2Icon },
];

function SideBar({ setMode }: { setMode: Dispatch<SetStateAction<DrawMode>> }) {
  return (
    <div className='w-[90px] bg-[var(--paint-primary)] h-full pt-2'>
      <div className='w-fit flex gap-1 m-auto'>
        {sidebarData.map((el) => {
          return (
            <Button
              key={el.name}
              variant={'paintIcon'}
              size={'sm'}
              onClick={() => setMode(el.name)}
            >
              <el.icon color={'#616161'} />
            </Button>
          );
        })}
      </div>
    </div>
  );
}

function Canvas({ mode }: { mode: DrawMode }) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [isDrawing, setIsDrawing] = useState<boolean>(false);
  const [ctx, setCtx] = useState<CanvasRenderingContext2D | null>(null);
  const [startPoint, setStartPoint] = useState<Point>({ x: 0, y: 0 });
  const [imageData, setImageData] = useState<ImageData | null>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const context = canvas.getContext('2d');

    if (context) {
      context.lineCap = 'round';
      context.strokeStyle = '#000';
      context.lineWidth = 3;
      setCtx(context);
    }
  }, []);

  const getMousePos = (e: React.MouseEvent<HTMLCanvasElement>): Point => {
    const canvas = canvasRef.current;
    if (!canvas) return { x: 0, y: 0 };

    const rect = canvas.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top,
    };
  };

  const startDrawing = (e: React.MouseEvent<HTMLCanvasElement>): void => {
    if (!ctx) return;

    const { x, y } = getMousePos(e);
    if (mode === 'draw') {
      ctx.beginPath();
      ctx.moveTo(x, y);
      setIsDrawing(true);
    } else if (mode === 'rect') {
      setStartPoint({ x, y });
      setIsDrawing(true);
      const canvas = canvasRef.current;
      if (canvas) {
        setImageData(ctx.getImageData(0, 0, canvas.width, canvas.height));
      }
    }
  };

  const draw = (e: React.MouseEvent<HTMLCanvasElement>): void => {
    if (!isDrawing || !ctx) return;

    const { x, y } = getMousePos(e);
    if (mode === 'draw') {
      ctx.lineTo(x, y);
      ctx.stroke();
    } else if (mode === 'rect' && imageData) {
      ctx.putImageData(imageData, 0, 0);
      const width = x - startPoint.x;
      const height = y - startPoint.y;
      ctx.strokeRect(startPoint.x, startPoint.y, width, height);
    }
  };

  const stopDrawing = (e: React.MouseEvent<HTMLCanvasElement>): void => {
    if (!isDrawing || !ctx) return;

    const { x, y } = getMousePos(e);
    if (mode === 'rect' && imageData) {
      const width = x - startPoint.x;
      const height = y - startPoint.y;
      ctx.putImageData(imageData, 0, 0);
      ctx.strokeRect(startPoint.x, startPoint.y, width, height);
    }
    ctx.closePath();
    setIsDrawing(false);
  };

  return (
    <canvas
      ref={canvasRef}
      style={{
        border: '1px solid #ccc',
        display: 'block',
        cursor: 'crosshair',
      }}
      onMouseDown={startDrawing}
      onMouseMove={draw}
      onMouseUp={stopDrawing}
      onMouseLeave={stopDrawing}
    />
  );
}
